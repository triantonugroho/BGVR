## 3.1. Introduction to Data Structures and Algorithms

### experiment_3.1_1

This code demonstrates a parallel, thread-safe Bloom Filter implementation in Rust for handling synthetic genomic data. The program generates a collection of random DNA sequences—each composed of bases A, C, G, and T—and inserts them into a Bloom Filter to enable efficient membership checks. By leveraging atomic booleans (AtomicBool) and parallel iterators (via the Rayon library), the code performs concurrent insertion and membership queries without the need for explicit locking. This design is especially relevant for large data sets, like genomic information, where high throughput and parallel data processing are crucial.

Internally, the Bloom Filter maintains a fixed-size bit array (m bits), along with k distinct hash functions. When inserting an item, each hash function determines a bit position in the array that is then set to true. For membership checks, all corresponding bits for the hashed positions must be true for the item to be possibly present; if any bit is false, it is definitely not in the set. The code uses Rust’s AtomicBool to ensure multiple threads can set bits safely, and it employs parallel iterators for distributing work across CPU cores, thereby increasing throughput when inserting or checking many items.

#### Project Structure:

```plaintext
experiment_3.1_1/
└── Cargo.toml                     # Rust project configuration and dependencies
src/
├── main.rs                        # Main Rust script containing program logic
└── output.txt                     # Text output file
```

#### Cargo.toml

```toml
[package]
name = "experiment_3.1_1"
version = "0.1.0"
edition = "2021"

[dependencies]
rand = "0.9.0"
rayon = "1.10.0"
```

#### How to run:

run in powershell:

```powershell
cargo run | tee output.txt
```

(run main.rs and save the output in output.txt)
  
#### Cargo.toml

```toml
[package]
name = "experiment_3.1_1"
version = "0.1.0"
edition = "2021"

[dependencies]
rand = "0.9.0"
rayon = "1.10.0"
```

#### Explanation of the Output:
The Rust program uses a Bloom Filter to insert and test the membership of DNA sequences. Here is a breakdown of the output:

##### 1. Sequence: TTAGTGAATACAGCTCTAAG => in Bloom Filter? true
  * This sequence is part of the dataset generated by the function generate_synthetic_genomic_data().
  * It was inserted into the Bloom Filter and has a high probability of being found as present when tested, which is why the result is true.

##### 2. Sequence: AACCACGAACCCAAAGTGCG => in Bloom Filter? true
* Similar to the previous sequence, this one is part of the dataset and was inserted into the Bloom Filter.
* The test also returns true, confirming the sequence is in the Bloom Filter.

##### 3. Sequence: CCAAGGTAAAAGTTCCGCAG => in Bloom Filter? false
* This sequence was randomly generated and is not part of the dataset.
* Since it was not inserted into the Bloom Filter, the test correctly returns false, meaning the sequence is not in the Bloom Filter.

##### 4. Sequence: ACGGGGCGCATAATCTCTTC => in Bloom Filter? false
* This is another randomly generated sequence that is not part of the dataset.
* The test correctly returns false since it was not inserted into the Bloom Filter.

#### Conclusion:
The Bloom Filter works as expected:
* It correctly identifies sequences that were inserted into it (true for known sequences).
* It correctly identifies sequences that were not inserted into it (false for random sequences not in the dataset).

#### Key Points:
* False positives: The Bloom Filter may sometimes give a true result for a sequence that was not actually inserted. However, since this program did not encounter false positives in this run (as expected for this simple test case), we conclude that the filter is functioning correctly. The risk of false positives increases with the size of the filter and the number of hash functions used.
* False negatives: A proper Bloom Filter (like the one used here) will never return false for an item that was actually inserted, which holds true in this case.
* Thus, this implementation is suitable for testing membership of sequences in a large dataset, especially where a small probability of false positives is acceptable.

