# 5. Sequence Analysis and Processing with Rust

## 5.1. Introduction to Sequence Analysis

### experiment_5.1_1
Rust code showcases a HyperLogLog (HLL) implementation in Rust, a probabilistic data structure designed for estimating the cardinality (the count of unique elements) of a data set.

### experiment_5.1_2
Rust code demonstrates a practical approach to high-throughput sequence data analysis using concurrency and partial output merging.

### experiment_5.1_3
Rust code merges multiple JSON files generated by the first program, each containing partial results from different chunks of data. 

## 5.2. Preprocessing and Quality Control

### experiment_5.2
Rust code applies a sliding window trimming algorithm to reads from a FASTQ file, chunk by chunk, and writes partial results to disk.

## 5.3. Alignment and Mapping Algorithms

### experiment_5.3
Rust code illustrates how to build partial FM-indexes for a reference genome and then perform parallel alignment of reads in Rust

## 5.4. De Novo Assembly Approaches

### experiment_5.4
Rust code demonstrates a chunk-based strategy for building a k-mer count table and constructing a minimal de Bruijn graph from potentially large FASTQ inputs.

## 5.5. Variant Calling and Genotyping

### experiment_5.5
Rust code processes variant hypotheses for a single or multiple genomic positions in a parallel and chunked fashion. 
 
## 5.6. Structural Variant Detection

### experiment_5.6
Rust code provides a parallelized, chunk-based approach to naive split-read detection for structural variant (SV) analysis.

## 5.7. RNA-seq and Transcriptomic Analysis

### experiment_5.7
Rust code uses rust-htslib to read a BAM file in chunks, tallying up transcript-level expression counts in parallel using Rayon.

## 5.8. Integrating Short and Long Reads

### experiment_5.8
Rust code demonstrates a “partial polishing” approach for hybrid assemblies, processing short-read alignments in chunks to build correction patches.

## 5.9. Summary of Key Concepts in Sequence Analysis

### experiment_5.9
Rust code chains alignment and variant calling in a parallel, chunked fashion, producing partial JSON outputs and merging them into a final result.
